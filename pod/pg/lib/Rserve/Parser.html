<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
	<meta charset='UTF-8'>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Rserve::Parser</title>
	<link rel="shortcut icon" href="/favicon.ico">
	<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet">
	<link href="//assets/podviewer.css" rel="stylesheet">
	<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js" defer></script>
	<script src="//assets/podviewer.js" defer></script>
</head>
<body>
	<div class="pod-header navbar navbar-dark bg-primary px-3 position-fixed border-bottom border-dark">
		<div class="container-fluid d-flex flex-column d-md-block">
			<h1 class="navbar-brand fw-bold fs-5 me-auto me-md-0 mb-2 mb-md-0">Rserve::Parser</h1>
			<button class="navbar-toggler d-md-none me-auto" type="button" data-bs-toggle="offcanvas"
				data-bs-target="#sidebar" aria-controls="sidebar" aria-label="Toggle Sidebar">
				<span class="navbar-toggler-icon"></span>
			</button>
		</div>
	</div>
	<aside class="offcanvas-md offcanvas-start border-end border-dark position-fixed" tabindex="-1"
		id="sidebar" aria-labelledby="sidebar-label">
		<div class="offcanvas-header">
			<h2 class="offcanvas-title" id="sidebar-label">Index</h2>
			<button type="button" class="btn-close" data-bs-dismiss="offcanvas" data-bs-target="#sidebar"
			   	aria-label="Close">
			</button>
		</div>
		<div class="offcanvas-body p-md-3 w-100">
			<nav>
				<ul class="nav flex-column w-100">
					<li class="nav-item">
						<a href="/" class="nav-link p-0">WeBWorK POD Home</a>
					</li>
					<li class="nav-item">
						<a href="http://webwork.maa.org/wiki/WeBWorK_Main_Page" class="nav-link p-0">WeBWorK Wiki</a>
					</li>
					<li><hr></li>
<li class="nav-item"><a class="nav-link p-0" href="#NAME">NAME</a></li><li class="nav-item"><a class="nav-link p-0" href="#SYNOPSIS">SYNOPSIS</a></li><li class="nav-item"><a class="nav-link p-0" href="#DESCRIPTION">DESCRIPTION</a></li><li class="nav-item"><a class="nav-link p-0" href="#FUNCTIONS">FUNCTIONS</a>
    <ul class="nav flex-column w-100">
      <li class="nav-item"><a class="nav-link p-0" href="#CHARACTER-PARSERS">CHARACTER PARSERS</a>
        <ul class="nav flex-column w-100">
          <li class="nav-item"><a class="nav-link p-0" href="#any_char">any_char</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#char">char</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#string">string</a></li>
        </ul>
      </li>
      <li class="nav-item"><a class="nav-link p-0" href="#NUMBER-PARSERS">NUMBER PARSERS</a>
        <ul class="nav flex-column w-100">
          <li class="nav-item"><a class="nav-link p-0" href="#endianness">endianness</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#any_uint8">any_uint8</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#any_uint16">any_uint16</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#any_uint24">any_uint24</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#any_uint32">any_uint32</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#uint8">uint8</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#uint16">uint16</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#uint24">uint24</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#uint32">uint32</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#any_int8">any_int8</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#any_int16">any_int16</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#any_int24">any_int24</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#any_int32">any_int32</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#int8">int8</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#int16">int16</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#int24">int24</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#int32">int32</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#any_real32">any_real32</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#any_real64">any_real64</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#any_int32_na">any_int32_na</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#any_real64_na">any_real64_na</a></li>
        </ul>
      </li>
      <li class="nav-item"><a class="nav-link p-0" href="#SEQUENCING">SEQUENCING</a>
        <ul class="nav flex-column w-100">
          <li class="nav-item"><a class="nav-link p-0" href="#seq">seq</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#many_till">many_till</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#count">count</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#with_count">with_count</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#choose">choose</a></li>
        </ul>
      </li>
      <li class="nav-item"><a class="nav-link p-0" href="#COMBINATORS">COMBINATORS</a>
        <ul class="nav flex-column w-100">
          <li class="nav-item"><a class="nav-link p-0" href="#bind">bind</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#mreturn">mreturn</a></li>
          <li class="nav-item"><a class="nav-link p-0" href="#error">error</a></li>
        </ul>
      </li>
    </ul>
  </li>				</ul>
			</nav>
		</div>
	</aside>
	<div class="pod-page-container d-flex">
		<div class="container-fluid p-3 h-100" id="_podtop_">


<a href="#_podtop_"><h1 id="NAME">NAME</h1></a>

<p>Rserve::Parser - Functions for parsing R data files</p>

<a href="#_podtop_"><h1 id="SYNOPSIS">SYNOPSIS</h1></a>

<pre><code>use Rserve::ParserState;
use Rserve::Parser;

my $state = Rserve::ParserState-&gt;new(
    data =&gt; &#39;file.rds&#39;
);
say $state-&gt;at
say $state-&gt;next-&gt;at;</code></pre>

<a href="#_podtop_"><h1 id="DESCRIPTION">DESCRIPTION</h1></a>

<p>You shouldn&#39;t create instances of this class, it exists mainly to handle deserialization of R data files.</p>

<a href="#_podtop_"><h1 id="FUNCTIONS">FUNCTIONS</h1></a>

<p>This library is inspired by monadic parser frameworks from the Haskell world, like <a href="http://bford.info/packrat/">Packrat</a> or <a href="http://hackage.haskell.org/package/parsec">Parsec</a>. What this means is that <i>parsers</i> are constructed by combining simpler parsers.</p>

<p>The library offers a selection of basic parsers and combinators. Each of these is a function (think of it as a factory) that returns another function (the actual parser) which receives the current parsing state (<a href="//pg/lib/Rserve/ParserState.html">Rserve::ParserState</a>) as the argument and returns a two-element array reference (called for brevity &quot;a pair&quot; in the following text) with the result of the parser in the first element and the new parser state in the second element. If the <i>parser</i> fails, say if the current state is &quot;a&quot; where a number is expected, it returns <code>undef</code> to signal failure.</p>

<p>The descriptions of individual functions below use a shorthand because the above mechanism is implied. Thus, when <code>any_char</code> is described as &quot;parses any character&quot;, it really means that calling <code>any_char</code> will return a function that when called with the current state will return &quot;a pair of the character...&quot;, etc.</p>

<h2 id="CHARACTER-PARSERS">CHARACTER PARSERS</h2>

<h3 id="any_char">any_char</h3>

<p>Parses any character, returning a pair of the character at the current State&#39;s position and the new state, advanced by one from the starting state. If the state is at the end (<code>$state-</code>eof&gt; is true), returns undef to signal failure.</p>

<h3 id="char">char</h3>

<pre><code>char($c)</code></pre>

<p>Parses the given character <code>$c</code>, returning a pair of the character at the current State&#39;s position if it is equal to <code>$c</code> and the new state, advanced by one from the starting state. If the state is at the end (<code>$state-</code>eof&gt; is true) or the character at the current position is not <code>$c</code>, returns undef to signal failure.</p>

<h3 id="string">string</h3>

<pre><code>string($s)</code></pre>

<p>Parses the given string <code>$s</code>, returning a pair of the sequence of characters starting at the current State&#39;s position if it is equal to <code>$s</code> and the new state, advanced by <code>length($s)</code> from the starting state. If the state is at the end (<code>$state-</code>eof&gt; is true) or the string starting at the current position is not <code>$s</code>, returns undef to signal failure.</p>

<h2 id="NUMBER-PARSERS">NUMBER PARSERS</h2>

<h3 id="endianness">endianness</h3>

<pre><code>endianness($end)</code></pre>

<p>The <code>$end</code> argument is optional and if given, this function sets the byte order used by parsers in the module to be little-endian if <code>$end</code> is &quot;&lt;&quot; or big-endian if <code>$end</code> is &quot;&gt;&quot;. This function changes the module&#39;s state and remains in effect until the next change.</p>

<p>When called with no arguments, <code>endianness</code> returns the current byte order in effect. The starting byte order is big-endian.</p>

<h3 id="any_uint8">any_uint8</h3>

<h3 id="any_uint16">any_uint16</h3>

<h3 id="any_uint24">any_uint24</h3>

<h3 id="any_uint32">any_uint32</h3>

<p>Parses an 8-, 16-, 24-, or 32-bit <i>unsigned</i> integer, returning a pair of the integer starting at the current State&#39;s position and the new state, advanced by 1, 2, 3, or 4 bytes from the starting state, depending on the parser. The integer value is determined by the current value of <code>endianness</code>. If there are not enough elements left in the data from the current position, returns undef to signal failure.</p>

<h3 id="uint8">uint8</h3>

<h3 id="uint16">uint16</h3>

<h3 id="uint24">uint24</h3>

<h3 id="uint32">uint32</h3>

<pre><code>uint8($n)
uint16($n)
uint24($n)
uint32($n)</code></pre>

<p>Parses the specified 8-, 16-, 24-, and 32-bit <i>unsigned</i> integer <code>$n</code>, returning a pair of the integer at the current State&#39;s position if it is equal <code>$n</code> and the new state. The new state is advanced by 1, 2, 3, or 4 bytes from the starting state, depending on the parser. The integer value is determined by the current value of <code>endianness</code>. If there are not enough elements left in the data from the current position or the current position is not <code>$n</code>, returns undef to signal failure.</p>

<h3 id="any_int8">any_int8</h3>

<h3 id="any_int16">any_int16</h3>

<h3 id="any_int24">any_int24</h3>

<h3 id="any_int32">any_int32</h3>

<p>Parses an 8-, 16-, 24-, and 32-bit <i>signed</i> integer, returning a pair of the integer starting at the current State&#39;s position and the new state, advanced by 1, 2, 3, or 4 bytes from the starting state, depending on the parser. The integer value is determined by the current value of <code>endianness</code>. If there are not enough elements left in the data from the current position, returns undef to signal failure.</p>

<h3 id="int8">int8</h3>

<h3 id="int16">int16</h3>

<h3 id="int24">int24</h3>

<h3 id="int32">int32</h3>

<pre><code>int8($n)
int16($n)
int24($n)
int32($n)</code></pre>

<p>Parses the specified 8-, 16-, 24-, and 32-bit <i>signed</i> integer <code>$n</code>, returning a pair of the integer at the current State&#39;s position if it is equal <code>$n</code> and the new state. The new state is advanced by 1, 2, 3, or 4 bytes from the starting state, depending on the parser. The integer value is determined by the current value of <code>endianness</code>. If there are not enough elements left in the data from the current position or the current position is not <code>$n</code>, returns undef to signal failure.</p>

<h3 id="any_real32">any_real32</h3>

<h3 id="any_real64">any_real64</h3>

<p>Parses an 32- or 64-bit real number, returning a pair of the number starting at the current State&#39;s position and the new state, advanced by 4 or 8 bytes from the starting state, depending on the parser. The real value is determined by the current value of <code>endianness</code>. If there are not enough elements left in the data from the current position, returns undef to signal failure.</p>

<h3 id="any_int32_na">any_int32_na</h3>

<h3 id="any_real64_na">any_real64_na</h3>

<p>Parses a 32-bit <i>signed</i> integer or 64-bit real number, respectively, but recognizing R-style missing values (NAs): INT_MIN for integers and a special NaN bit pattern for reals. Returns a pair of the number value (<code>undef</code> if a NA) and the new state, advanced by 4 or 8 bytes from the starting state, depending on the parser. If there are not enough elements left in the data from the current position, returns undef to signal failure.</p>

<h2 id="SEQUENCING">SEQUENCING</h2>

<h3 id="seq">seq</h3>

<pre><code>seq($p1, $p2, ...)</code></pre>

<p>This combinator applies parsers <code>$p1</code>, <code>$p2</code>, ... in sequence, using the returned parse state of <code>$p1</code> as the input parse state to <code>$p2</code>, etc. Returns a pair of the concatenation of all the parsers&#39; results and the parsing state returned by the final parser. If any of the parsers returns undef, <code>seq</code> will return it immediately without attempting to apply any further parsers.</p>

<h3 id="many_till">many_till</h3>

<pre><code>many_till($p, $end)</code></pre>

<p>This combinator applies a parser <code>$p</code> until parser <code>$end</code> succeeds. It does this by alternating applications of <code>$end</code> and <code>$p</code>; once <code>$end</code> succeeds, the function returns the concatenation of results of preceding applications of <code>$p</code>. (Thus, if <code>$end</code> succeeds immediately, the &#39;result&#39; is an empty list.) Otherwise, <code>$p</code> is applied and must succeed, and the procedure repeats. Returns a pair of the concatenation of all the <code>$p</code>&#39;s results and the parsing state returned by the final parser. If any applications of <code>$p</code> returns undef, <code>many_till</code> will return it immediately.</p>

<h3 id="count">count</h3>

<pre><code>count($n, $p)</code></pre>

<p>This combinator applies the parser <code>$p</code> exactly <code>$n</code> times in sequence, threading the parse state through each call. Returns a pair of the concatenation of all the parsers&#39; results and the parsing state returned by the final application. If any application of <code>$p</code> returns undef, <code>count</code> will return it immediately without attempting any more applications.</p>

<h3 id="with_count">with_count</h3>

<pre><code>with_count($num_p, $p)
with_count($p)</code></pre>

<p>This combinator first applies parser <code>$num_p</code> to get the number of times that <code>$p</code> should be applied in sequence. If only one argument is given, <code>any_uint32</code> is used as the default value of <code>$num_p</code>. (So <code>with_count</code> works by getting a number <i>$n</i> by applying <code>$num_p</code> and then calling <code>count $n, $p</code>.) Returns a pair of the concatenation of all the parsers&#39; results and the parsing state returned by the final application. If the initial application of <code>$num_p</code> or any application of <code>$p</code> returns undef, <code>with_count</code> will return it immediately without attempting any more applications.</p>

<h3 id="choose">choose</h3>

<pre><code>choose($p1, $p2, ...)</code></pre>

<p>This combinator applies parsers <code>$p1</code>, <code>$p2</code>, ... in sequence, until one of them succeeds, when it immediately returns the parser&#39;s result. If all of the parsers fail, <code>choose</code> fails and returns undef.</p>

<h2 id="COMBINATORS">COMBINATORS</h2>

<h3 id="bind">bind</h3>

<pre><code>bind($p1, $f)</code></pre>

<p>This combinator applies parser <code>$p1</code> and, if it succeeds, calls function <code>$f</code> using the first element of <code>$p1</code>&#39;s result as the argument. The call to <code>$f</code> needs to return a parser, which <code>bind</code> applies to the parsing state after <code>$p1</code>&#39;s application.</p>

<p>The <code>bind</code> combinator is an essential building block for most combinators described so far. For instance, <code>with_count</code> can be written as:</p>

<pre><code>bind($num_p,
     sub {
         my $n = shift;
         count $n, $p;
     })</code></pre>

<h3 id="mreturn">mreturn</h3>

<pre><code>mreturn($value)</code></pre>

<p>Returns a parser that when applied returns <code>$value</code> without changing the parsing state.</p>

<h3 id="error">error</h3>

<pre><code>error($message)</code></pre>

<p>Returns a parser that when applied croaks with the <code>$message</code> and the current parsing state.</p>

		</div>
	</div>
</body>
</html>
