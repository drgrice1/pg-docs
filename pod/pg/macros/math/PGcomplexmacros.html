<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
<meta charset='UTF-8'>
<link rel="icon" href="/favicon.ico">
<title>math/PGcomplexmacros.pl</title>
</head>
<body>
<h1>math/PGcomplexmacros.pl</h1>
<div style="margin-left:20px">Jump to: <a href="#column-one">Site Navigation</a></div>
<hr>
<div id="_podtop_">


<ul id="index">
  <li><a href="#NAME">NAME</a></li>
  <li><a href="#SYNPOSIS">SYNPOSIS</a></li>
  <li><a href="#DESCRIPTION">DESCRIPTION</a>
    <ul>
      <li>
        <ul>
          <li><a href="#cplx_cmp">cplx_cmp</a></li>
          <li><a href="#compare_cplx">compare_cplx</a></li>
          <li><a href="#multi_cmp">multi_cmp</a></li>
        </ul>
      </li>
      <li><a href="#Utility-functions">Utility functions</a>
        <ul>
          <li>
            <ul>
              <li><a href="#single_term">single_term()</a></li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<a href="#_podtop_"><h1 id="NAME">NAME</h1></a>

<pre><code>        Macros for complex numbers for the PG language</code></pre>

<a href="#_podtop_"><h1 id="SYNPOSIS">SYNPOSIS</h1></a>

<a href="#_podtop_"><h1 id="DESCRIPTION">DESCRIPTION</h1></a>

<h3 id="cplx_cmp">cplx_cmp</h3>

<pre><code> #      This subroutine compares complex numbers.
 #      Available prefilters include:
 #      each of these are called by cplx_cmp( answer, mode =&gt; &#39;(prefilter name)&#39; )
 #      &#39;std&#39;                   The standard comparison method for complex numbers. This option it the default
 #                              and works with any combination of cartesian numbers, polar numbers, and
 #                              functions. The default display method is cartesian, for all methods, but if
 #                              the student answer is polar, even in part, then their answer will be displayed
 #                              that way.
 #      &#39;strict_polar&#39;          This is still under developement. The idea is to check to make sure that there
 #                              only a single term in front of the e and after it... but the method does not
 #                              check to make sure that the i is in the exponent, nor does it handle cases
 #                              where the polar has e** coefficients.
 #      &#39;strict_num_cartesian&#39;  This prefilter allows only complex numbers of the form &quot;a+bi&quot; where a and b
 #                              are strictly numbers.
 #      &#39;strict_num_polar&#39;      This prefilter allows only complex numbers of the form &quot;ae^(bi)&quot; where a and b
 #                              are strictly numbers.
 #      &#39;strict&#39;                This is a combination of strict_num_cartesian and strict_num_polar, so it
 #                              allows complex numbers of either the form &quot;a+bi&quot; or &quot;ae^(bi)&quot; where a and b
 #                              are strictly numbers.</code></pre>

<h3 id="compare_cplx">compare_cplx</h3>

<pre><code> #      This is a filter: it accepts and returns an AnswerHash object.
 #
 #              Usage:  compare_cplx(ans_hash, %options)
 #
 #      Compares two complex numbers by comparing their real and imaginary parts</code></pre>

<h3 id="multi_cmp">multi_cmp</h3>

<pre><code> #      
 #      Checks a comma separated string of  items against an array of evaluators.
 #      For example this is useful for checking all of the complex roots of an equation.
 #      Each student answer must be evaluated as correct by a DISTINCT answer evalutor.
 #      
 #      This answer checker will only work reliably if each answer checker corresponds
 #      to a distinct correct answer.  For example if one answer checker requires
 #      any positive number, and the second requires the answer 1, then 1,2 might
 #      be judged incorrect since 1, satisifes the first answer checker, but 2 doesn&#39;t
 #      satisfy the second.  2,1 would work however. Avoid this type of use!!
 #      
 #      Including backtracking to fit the answers as best possible to each answer evaluator
 #      in the best possible way, is beyond the ambitions of this evaluator.</code></pre>

<h2 id="Utility-functions">Utility functions</h2>

<pre><code> #      for checking the form of a number or of the &lt;student_ans&gt; field in an answer hash</code></pre>

<h4 id="single_term">single_term()</h4>

<pre><code> #      This subroutine takes in a string, which is a mathematical expresion, and determines whether or not
 #      it is a single term. This is accoplished using a stack. Open parenthesis pluses and minuses are all
 #      added onto the stack, and when a closed parenthesis is reached, the stack is popped untill the open
 #      parenthesis is found. If the original was a single term, the stack should be empty after
 #      evaluation. If there is anything left ( + or - ) then false is returned.
 #      Of course, the unary operator &quot;-&quot; must be handled... if it is a unary operator, and not a regular -
 #      the only place it could occur unambiguously without being surrounded by parenthesis, is the very
 #      first position. So that case is checked before the loop begins.
        </code></pre>

</div>
<hr>
<div id="column-one">
<h5>Site Navigation</h5>
<div>
<ul>
<li><a href="/pod">WeBWorK POD Home</a></li>
<li><a href="http://webwork.maa.org/wiki/WeBWorK_Main_Page">WeBWorK Wiki</a></li>
</ul>
</div>
</div>
</body>
</html>


